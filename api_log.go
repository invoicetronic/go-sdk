/*
Italian eInvoice API

The Italian eInvoice API is a RESTful API that allows you to send and receive invoices through the Italian [Servizio di Interscambio (SDI)][1], or Interchange Service. The API is designed by Invoicetronic to be simple and easy to use, abstracting away SDI complexity while providing complete control over the invoice send/receive process. The API also provides advanced features as encryption at rest, invoice validation, multiple upload formats, webhooks, event logging, client SDKs for commonly used languages, and CLI tools.  For more information, see  [Invoicetronic website][2]  [1]: https://www.fatturapa.gov.it/it/sistemainterscambio/cose-il-sdi/ [2]: https://invoicetronic.com/

API version: 1.0.0
Contact: support@invoicetronic.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package invoicesdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// LogAPIService LogAPI service
type LogAPIService service

type ApiInvoiceV1LogGetRequest struct {
	ctx context.Context
	ApiService *LogAPIService
	companyId *int32
	endpoint *string
	method *string
	apiVerion *int32
	statusCode *int32
	dateCreatedFrom *time.Time
	dateCreatedTo *time.Time
	page *int32
	pageSize *int32
}

// Company id
func (r ApiInvoiceV1LogGetRequest) CompanyId(companyId int32) ApiInvoiceV1LogGetRequest {
	r.companyId = &companyId
	return r
}

func (r ApiInvoiceV1LogGetRequest) Endpoint(endpoint string) ApiInvoiceV1LogGetRequest {
	r.endpoint = &endpoint
	return r
}

func (r ApiInvoiceV1LogGetRequest) Method(method string) ApiInvoiceV1LogGetRequest {
	r.method = &method
	return r
}

// Api version
func (r ApiInvoiceV1LogGetRequest) ApiVerion(apiVerion int32) ApiInvoiceV1LogGetRequest {
	r.apiVerion = &apiVerion
	return r
}

// Response status code
func (r ApiInvoiceV1LogGetRequest) StatusCode(statusCode int32) ApiInvoiceV1LogGetRequest {
	r.statusCode = &statusCode
	return r
}

// UTC ISO 8601 (2024-11-29T12:34:56Z)
func (r ApiInvoiceV1LogGetRequest) DateCreatedFrom(dateCreatedFrom time.Time) ApiInvoiceV1LogGetRequest {
	r.dateCreatedFrom = &dateCreatedFrom
	return r
}

// UTC ISO 8601 (2024-11-29T12:34:56Z)
func (r ApiInvoiceV1LogGetRequest) DateCreatedTo(dateCreatedTo time.Time) ApiInvoiceV1LogGetRequest {
	r.dateCreatedTo = &dateCreatedTo
	return r
}

// Page number. Defaults to 1.
func (r ApiInvoiceV1LogGetRequest) Page(page int32) ApiInvoiceV1LogGetRequest {
	r.page = &page
	return r
}

// Items per page. Defaults to 50. Cannot be greater than 200.
func (r ApiInvoiceV1LogGetRequest) PageSize(pageSize int32) ApiInvoiceV1LogGetRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiInvoiceV1LogGetRequest) Execute() ([]Event, *http.Response, error) {
	return r.ApiService.InvoiceV1LogGetExecute(r)
}

/*
InvoiceV1LogGet List events

Every API operation is logged and can be retrieved here.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInvoiceV1LogGetRequest
*/
func (a *LogAPIService) InvoiceV1LogGet(ctx context.Context) ApiInvoiceV1LogGetRequest {
	return ApiInvoiceV1LogGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Event
func (a *LogAPIService) InvoiceV1LogGetExecute(r ApiInvoiceV1LogGetRequest) ([]Event, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogAPIService.InvoiceV1LogGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoice/v1/log"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.companyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "company_id", r.companyId, "form", "")
	}
	if r.endpoint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endpoint", r.endpoint, "form", "")
	}
	if r.method != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "method", r.method, "form", "")
	}
	if r.apiVerion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api_verion", r.apiVerion, "form", "")
	}
	if r.statusCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status_code", r.statusCode, "form", "")
	}
	if r.dateCreatedFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_created_from", r.dateCreatedFrom, "form", "")
	}
	if r.dateCreatedTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_created_to", r.dateCreatedTo, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInvoiceV1LogIdGetRequest struct {
	ctx context.Context
	ApiService *LogAPIService
	id int32
}

func (r ApiInvoiceV1LogIdGetRequest) Execute() (*Event, *http.Response, error) {
	return r.ApiService.InvoiceV1LogIdGetExecute(r)
}

/*
InvoiceV1LogIdGet Get an event by id

Every API operation is logged and can be retrieved here.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item id
 @return ApiInvoiceV1LogIdGetRequest
*/
func (a *LogAPIService) InvoiceV1LogIdGet(ctx context.Context, id int32) ApiInvoiceV1LogIdGetRequest {
	return ApiInvoiceV1LogIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Event
func (a *LogAPIService) InvoiceV1LogIdGetExecute(r ApiInvoiceV1LogIdGetRequest) (*Event, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogAPIService.InvoiceV1LogIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoice/v1/log/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
