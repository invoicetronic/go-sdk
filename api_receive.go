/*
Italian eInvoice API v1

The [Italian eInvoice API][2] is a RESTful API that allows you to send and receive invoices through the Italian [Servizio di Interscambio (SDI)][1], or Interchange Service. The API is designed by Invoicetronic to be simple and easy to use, abstracting away SDI complexity while providing complete control over the invoice send/receive process. The API also provides advanced features as encryption at rest, invoice validation, multiple upload formats, webhooks, event logging, client SDKs for commonly used languages, and CLI tools.  For more information, see  [Invoicetronic website][2]  [1]: https://www.fatturapa.gov.it/it/sistemainterscambio/cose-il-sdi/ [2]: https://invoicetronic.com/

API version: 1
Contact: support@invoicetronic.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package invoicesdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// ReceiveAPIService ReceiveAPI service
type ReceiveAPIService service

type ApiReceiveGetRequest struct {
	ctx context.Context
	ApiService *ReceiveAPIService
	companyId *int32
	identifier *string
	unread *bool
	committente *string
	prestatore *string
	fileName *string
	lastUpdateFrom *time.Time
	lastUpdateTo *time.Time
	dateSentFrom *time.Time
	dateSentTo *time.Time
	documentDateFrom *time.Time
	documentDateTo *time.Time
	documentNumber *string
	page *int32
	pageSize *int32
	sort *string
}

// Company id
func (r ApiReceiveGetRequest) CompanyId(companyId int32) ApiReceiveGetRequest {
	r.companyId = &companyId
	return r
}

// SDI identifier.
func (r ApiReceiveGetRequest) Identifier(identifier string) ApiReceiveGetRequest {
	r.identifier = &identifier
	return r
}

// Unread items only.
func (r ApiReceiveGetRequest) Unread(unread bool) ApiReceiveGetRequest {
	r.unread = &unread
	return r
}

// Vat number or fiscal code.
func (r ApiReceiveGetRequest) Committente(committente string) ApiReceiveGetRequest {
	r.committente = &committente
	return r
}

// Vat number or fiscal code.
func (r ApiReceiveGetRequest) Prestatore(prestatore string) ApiReceiveGetRequest {
	r.prestatore = &prestatore
	return r
}

// File name.
func (r ApiReceiveGetRequest) FileName(fileName string) ApiReceiveGetRequest {
	r.fileName = &fileName
	return r
}

// UTC ISO 8601 (2024-11-29T12:34:56Z)
func (r ApiReceiveGetRequest) LastUpdateFrom(lastUpdateFrom time.Time) ApiReceiveGetRequest {
	r.lastUpdateFrom = &lastUpdateFrom
	return r
}

// UTC ISO 8601 (2024-11-29T12:34:56Z)
func (r ApiReceiveGetRequest) LastUpdateTo(lastUpdateTo time.Time) ApiReceiveGetRequest {
	r.lastUpdateTo = &lastUpdateTo
	return r
}

// UTC ISO 8601 (2024-11-29T12:34:56Z)
func (r ApiReceiveGetRequest) DateSentFrom(dateSentFrom time.Time) ApiReceiveGetRequest {
	r.dateSentFrom = &dateSentFrom
	return r
}

// UTC ISO 8601 (2024-11-29T12:34:56Z)
func (r ApiReceiveGetRequest) DateSentTo(dateSentTo time.Time) ApiReceiveGetRequest {
	r.dateSentTo = &dateSentTo
	return r
}

// UTC ISO 8601 (2024-11-29T12:34:56Z)
func (r ApiReceiveGetRequest) DocumentDateFrom(documentDateFrom time.Time) ApiReceiveGetRequest {
	r.documentDateFrom = &documentDateFrom
	return r
}

// UTC ISO 8601 (2024-11-29T12:34:56Z)
func (r ApiReceiveGetRequest) DocumentDateTo(documentDateTo time.Time) ApiReceiveGetRequest {
	r.documentDateTo = &documentDateTo
	return r
}

// Document number.
func (r ApiReceiveGetRequest) DocumentNumber(documentNumber string) ApiReceiveGetRequest {
	r.documentNumber = &documentNumber
	return r
}

// Page number. Defaults to 1.
func (r ApiReceiveGetRequest) Page(page int32) ApiReceiveGetRequest {
	r.page = &page
	return r
}

// Items per page. Defaults to 50. Cannot be greater than 200.
func (r ApiReceiveGetRequest) PageSize(pageSize int32) ApiReceiveGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sort by field. Prefix with &#39;-&#39; for descending order.
func (r ApiReceiveGetRequest) Sort(sort string) ApiReceiveGetRequest {
	r.sort = &sort
	return r
}

func (r ApiReceiveGetRequest) Execute() ([]Receive, *http.Response, error) {
	return r.ApiService.ReceiveGetExecute(r)
}

/*
ReceiveGet List incoming invoices

Receive invoices are the invoices that are received from other companies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReceiveGetRequest
*/
func (a *ReceiveAPIService) ReceiveGet(ctx context.Context) ApiReceiveGetRequest {
	return ApiReceiveGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Receive
func (a *ReceiveAPIService) ReceiveGetExecute(r ApiReceiveGetRequest) ([]Receive, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Receive
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReceiveAPIService.ReceiveGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/receive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.companyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "company_id", r.companyId, "form", "")
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "form", "")
	}
	if r.unread != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unread", r.unread, "form", "")
	}
	if r.committente != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "committente", r.committente, "form", "")
	}
	if r.prestatore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prestatore", r.prestatore, "form", "")
	}
	if r.fileName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "file_name", r.fileName, "form", "")
	}
	if r.lastUpdateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_update_from", r.lastUpdateFrom, "form", "")
	}
	if r.lastUpdateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_update_to", r.lastUpdateTo, "form", "")
	}
	if r.dateSentFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_sent_from", r.dateSentFrom, "form", "")
	}
	if r.dateSentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_sent_to", r.dateSentTo, "form", "")
	}
	if r.documentDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "document_date_from", r.documentDateFrom, "form", "")
	}
	if r.documentDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "document_date_to", r.documentDateTo, "form", "")
	}
	if r.documentNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "document_number", r.documentNumber, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReceiveIdDeleteRequest struct {
	ctx context.Context
	ApiService *ReceiveAPIService
	id int32
}

func (r ApiReceiveIdDeleteRequest) Execute() (*Receive, *http.Response, error) {
	return r.ApiService.ReceiveIdDeleteExecute(r)
}

/*
ReceiveIdDelete Delete an incoming invoice by id

Receive invoices are the invoices that are received from other companies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item id
 @return ApiReceiveIdDeleteRequest
*/
func (a *ReceiveAPIService) ReceiveIdDelete(ctx context.Context, id int32) ApiReceiveIdDeleteRequest {
	return ApiReceiveIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Receive
func (a *ReceiveAPIService) ReceiveIdDeleteExecute(r ApiReceiveIdDeleteRequest) (*Receive, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Receive
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReceiveAPIService.ReceiveIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/receive/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReceiveIdGetRequest struct {
	ctx context.Context
	ApiService *ReceiveAPIService
	id int32
}

func (r ApiReceiveIdGetRequest) Execute() (*Receive, *http.Response, error) {
	return r.ApiService.ReceiveIdGetExecute(r)
}

/*
ReceiveIdGet Get an incoming invoice by id

Receive invoices are the invoices that are received from other companies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item id
 @return ApiReceiveIdGetRequest
*/
func (a *ReceiveAPIService) ReceiveIdGet(ctx context.Context, id int32) ApiReceiveIdGetRequest {
	return ApiReceiveIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Receive
func (a *ReceiveAPIService) ReceiveIdGetExecute(r ApiReceiveIdGetRequest) (*Receive, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Receive
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReceiveAPIService.ReceiveIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/receive/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
