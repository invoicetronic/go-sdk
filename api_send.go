/*
Italian eInvoice API v1

The [Italian eInvoice API][2] is a RESTful API that allows you to send and receive invoices through the Italian [Servizio di Interscambio (SDI)][1], or Interchange Service. The API is designed by Invoicetronic to be simple and easy to use, abstracting away SDI complexity while providing complete control over the invoice send/receive process. The API also provides advanced features as encryption at rest, invoice validation, multiple upload formats, webhooks, event logging, client SDKs for commonly used languages, and CLI tools.  For more information, see  [Invoicetronic website][2]  [1]: https://www.fatturapa.gov.it/it/sistemainterscambio/cose-il-sdi/ [2]: https://invoicetronic.com/

API version: 1
Contact: support@invoicetronic.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package invoicesdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"time"
)


// SendAPIService SendAPI service
type SendAPIService service

type ApiSendFilePostRequest struct {
	ctx context.Context
	ApiService *SendAPIService
	file *os.File
	validate *bool
	signature *string
}

func (r ApiSendFilePostRequest) File(file *os.File) ApiSendFilePostRequest {
	r.file = file
	return r
}

// Validate the document first, and reject it on failure.
func (r ApiSendFilePostRequest) Validate(validate bool) ApiSendFilePostRequest {
	r.validate = &validate
	return r
}

// Whether to digitally sign the document.
func (r ApiSendFilePostRequest) Signature(signature string) ApiSendFilePostRequest {
	r.signature = &signature
	return r
}

func (r ApiSendFilePostRequest) Execute() (*Send, *http.Response, error) {
	return r.ApiService.SendFilePostExecute(r)
}

/*
SendFilePost Add an invoice by file

Send invoices are the invoices that are sent to the SDI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendFilePostRequest
*/
func (a *SendAPIService) SendFilePost(ctx context.Context) ApiSendFilePostRequest {
	return ApiSendFilePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Send
func (a *SendAPIService) SendFilePostExecute(r ApiSendFilePostRequest) (*Send, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Send
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendAPIService.SendFilePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/send/file"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	if r.validate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validate", r.validate, "form", "")
	} else {
		var defaultValue bool = false
		r.validate = &defaultValue
	}
	if r.signature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signature", r.signature, "form", "")
	} else {
		var defaultValue string = "Auto"
		r.signature = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendGetRequest struct {
	ctx context.Context
	ApiService *SendAPIService
	companyId *int32
	identifier *string
	committente *string
	prestatore *string
	fileName *string
	lastUpdateFrom *time.Time
	lastUpdateTo *time.Time
	dateSentFrom *time.Time
	dateSentTo *time.Time
	documentDateFrom *time.Time
	documentDateTo *time.Time
	documentNumber *string
	page *int32
	pageSize *int32
	sort *string
}

// Company id
func (r ApiSendGetRequest) CompanyId(companyId int32) ApiSendGetRequest {
	r.companyId = &companyId
	return r
}

// SDI identifier.
func (r ApiSendGetRequest) Identifier(identifier string) ApiSendGetRequest {
	r.identifier = &identifier
	return r
}

// Vat number or fiscal code.
func (r ApiSendGetRequest) Committente(committente string) ApiSendGetRequest {
	r.committente = &committente
	return r
}

// Vat number or fiscal code.
func (r ApiSendGetRequest) Prestatore(prestatore string) ApiSendGetRequest {
	r.prestatore = &prestatore
	return r
}

// File name.
func (r ApiSendGetRequest) FileName(fileName string) ApiSendGetRequest {
	r.fileName = &fileName
	return r
}

// UTC ISO 8601 (2024-11-29T12:34:56Z)
func (r ApiSendGetRequest) LastUpdateFrom(lastUpdateFrom time.Time) ApiSendGetRequest {
	r.lastUpdateFrom = &lastUpdateFrom
	return r
}

// UTC ISO 8601 (2024-11-29T12:34:56Z)
func (r ApiSendGetRequest) LastUpdateTo(lastUpdateTo time.Time) ApiSendGetRequest {
	r.lastUpdateTo = &lastUpdateTo
	return r
}

// UTC ISO 8601 (2024-11-29T12:34:56Z)
func (r ApiSendGetRequest) DateSentFrom(dateSentFrom time.Time) ApiSendGetRequest {
	r.dateSentFrom = &dateSentFrom
	return r
}

// UTC ISO 8601 (2024-11-29T12:34:56Z)
func (r ApiSendGetRequest) DateSentTo(dateSentTo time.Time) ApiSendGetRequest {
	r.dateSentTo = &dateSentTo
	return r
}

// UTC ISO 8601 (2024-11-29T12:34:56Z)
func (r ApiSendGetRequest) DocumentDateFrom(documentDateFrom time.Time) ApiSendGetRequest {
	r.documentDateFrom = &documentDateFrom
	return r
}

// UTC ISO 8601 (2024-11-29T12:34:56Z)
func (r ApiSendGetRequest) DocumentDateTo(documentDateTo time.Time) ApiSendGetRequest {
	r.documentDateTo = &documentDateTo
	return r
}

// Document number.
func (r ApiSendGetRequest) DocumentNumber(documentNumber string) ApiSendGetRequest {
	r.documentNumber = &documentNumber
	return r
}

// Page number. Defaults to 1.
func (r ApiSendGetRequest) Page(page int32) ApiSendGetRequest {
	r.page = &page
	return r
}

// Items per page. Defaults to 50. Cannot be greater than 200.
func (r ApiSendGetRequest) PageSize(pageSize int32) ApiSendGetRequest {
	r.pageSize = &pageSize
	return r
}

// Sort by field. Prefix with &#39;-&#39; for descending order.
func (r ApiSendGetRequest) Sort(sort string) ApiSendGetRequest {
	r.sort = &sort
	return r
}

func (r ApiSendGetRequest) Execute() ([]Send, *http.Response, error) {
	return r.ApiService.SendGetExecute(r)
}

/*
SendGet List invoices

test **markdown**.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendGetRequest
*/
func (a *SendAPIService) SendGet(ctx context.Context) ApiSendGetRequest {
	return ApiSendGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Send
func (a *SendAPIService) SendGetExecute(r ApiSendGetRequest) ([]Send, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Send
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendAPIService.SendGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/send"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.companyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "company_id", r.companyId, "form", "")
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "form", "")
	}
	if r.committente != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "committente", r.committente, "form", "")
	}
	if r.prestatore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prestatore", r.prestatore, "form", "")
	}
	if r.fileName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "file_name", r.fileName, "form", "")
	}
	if r.lastUpdateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_update_from", r.lastUpdateFrom, "form", "")
	}
	if r.lastUpdateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_update_to", r.lastUpdateTo, "form", "")
	}
	if r.dateSentFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_sent_from", r.dateSentFrom, "form", "")
	}
	if r.dateSentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_sent_to", r.dateSentTo, "form", "")
	}
	if r.documentDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "document_date_from", r.documentDateFrom, "form", "")
	}
	if r.documentDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "document_date_to", r.documentDateTo, "form", "")
	}
	if r.documentNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "document_number", r.documentNumber, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendIdGetRequest struct {
	ctx context.Context
	ApiService *SendAPIService
	id int32
}

func (r ApiSendIdGetRequest) Execute() (*Send, *http.Response, error) {
	return r.ApiService.SendIdGetExecute(r)
}

/*
SendIdGet Get a invoice by id

Send invoices are the invoices that are sent to the SDI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Item id
 @return ApiSendIdGetRequest
*/
func (a *SendAPIService) SendIdGet(ctx context.Context, id int32) ApiSendIdGetRequest {
	return ApiSendIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Send
func (a *SendAPIService) SendIdGetExecute(r ApiSendIdGetRequest) (*Send, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Send
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendAPIService.SendIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/send/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendJsonPostRequest struct {
	ctx context.Context
	ApiService *SendAPIService
	fatturaOrdinaria *FatturaOrdinaria
	validate *bool
	signature *string
}

func (r ApiSendJsonPostRequest) FatturaOrdinaria(fatturaOrdinaria FatturaOrdinaria) ApiSendJsonPostRequest {
	r.fatturaOrdinaria = &fatturaOrdinaria
	return r
}

// Validate the document first, and reject it on failure.
func (r ApiSendJsonPostRequest) Validate(validate bool) ApiSendJsonPostRequest {
	r.validate = &validate
	return r
}

// Whether to digitally sign the document.
func (r ApiSendJsonPostRequest) Signature(signature string) ApiSendJsonPostRequest {
	r.signature = &signature
	return r
}

func (r ApiSendJsonPostRequest) Execute() (*Send, *http.Response, error) {
	return r.ApiService.SendJsonPostExecute(r)
}

/*
SendJsonPost Add an invoice by json

Send invoices are the invoices that are sent to the SDI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendJsonPostRequest
*/
func (a *SendAPIService) SendJsonPost(ctx context.Context) ApiSendJsonPostRequest {
	return ApiSendJsonPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Send
func (a *SendAPIService) SendJsonPostExecute(r ApiSendJsonPostRequest) (*Send, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Send
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendAPIService.SendJsonPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/send/json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fatturaOrdinaria == nil {
		return localVarReturnValue, nil, reportError("fatturaOrdinaria is required and must be specified")
	}

	if r.validate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validate", r.validate, "form", "")
	} else {
		var defaultValue bool = false
		r.validate = &defaultValue
	}
	if r.signature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signature", r.signature, "form", "")
	} else {
		var defaultValue string = "Auto"
		r.signature = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fatturaOrdinaria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendPostRequest struct {
	ctx context.Context
	ApiService *SendAPIService
	send *Send
	validate *bool
	signature *string
}

func (r ApiSendPostRequest) Send(send Send) ApiSendPostRequest {
	r.send = &send
	return r
}

// Validate the document first, and reject it on failure.
func (r ApiSendPostRequest) Validate(validate bool) ApiSendPostRequest {
	r.validate = &validate
	return r
}

// Whether to digitally sign the document.
func (r ApiSendPostRequest) Signature(signature string) ApiSendPostRequest {
	r.signature = &signature
	return r
}

func (r ApiSendPostRequest) Execute() (*Send, *http.Response, error) {
	return r.ApiService.SendPostExecute(r)
}

/*
SendPost Add an invoice

Send invoices are the invoices that are sent to the SDI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendPostRequest
*/
func (a *SendAPIService) SendPost(ctx context.Context) ApiSendPostRequest {
	return ApiSendPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Send
func (a *SendAPIService) SendPostExecute(r ApiSendPostRequest) (*Send, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Send
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendAPIService.SendPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/send"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.send == nil {
		return localVarReturnValue, nil, reportError("send is required and must be specified")
	}

	if r.validate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validate", r.validate, "form", "")
	} else {
		var defaultValue bool = false
		r.validate = &defaultValue
	}
	if r.signature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signature", r.signature, "form", "")
	} else {
		var defaultValue string = "Auto"
		r.signature = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.send
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendValidateFilesPostRequest struct {
	ctx context.Context
	ApiService *SendAPIService
	files []*os.File
}

func (r ApiSendValidateFilesPostRequest) Files(files []*os.File) ApiSendValidateFilesPostRequest {
	r.files = files
	return r
}

func (r ApiSendValidateFilesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendValidateFilesPostExecute(r)
}

/*
SendValidateFilesPost Validate an invoice by file

Send invoices are the invoices that are sent to the SDI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendValidateFilesPostRequest
*/
func (a *SendAPIService) SendValidateFilesPost(ctx context.Context) ApiSendValidateFilesPostRequest {
	return ApiSendValidateFilesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SendAPIService) SendValidateFilesPostExecute(r ApiSendValidateFilesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendAPIService.SendValidateFilesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/send/validate/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.files == nil {
		return nil, reportError("files is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var filesLocalVarFormFileName string
	var filesLocalVarFileName     string
	var filesLocalVarFileBytes    []byte

	filesLocalVarFormFileName = "files"
	filesLocalVarFile := r.files

	if filesLocalVarFile != nil {
		// loop through the array to prepare multiple files upload
		for _, filesLocalVarFileValue := range filesLocalVarFile {
			fbs, _ := io.ReadAll(filesLocalVarFileValue)

			filesLocalVarFileBytes = fbs
			filesLocalVarFileName = filesLocalVarFileValue.Name()
			filesLocalVarFileValue.Close()
			formFiles = append(formFiles, formFile{fileBytes: filesLocalVarFileBytes, fileName: filesLocalVarFileName, formFileName: filesLocalVarFormFileName})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendValidateJsonPostRequest struct {
	ctx context.Context
	ApiService *SendAPIService
	fatturaOrdinaria *FatturaOrdinaria
}

func (r ApiSendValidateJsonPostRequest) FatturaOrdinaria(fatturaOrdinaria FatturaOrdinaria) ApiSendValidateJsonPostRequest {
	r.fatturaOrdinaria = &fatturaOrdinaria
	return r
}

func (r ApiSendValidateJsonPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendValidateJsonPostExecute(r)
}

/*
SendValidateJsonPost Validate an invoice by json

Send invoices are the invoices that are sent to the SDI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendValidateJsonPostRequest
*/
func (a *SendAPIService) SendValidateJsonPost(ctx context.Context) ApiSendValidateJsonPostRequest {
	return ApiSendValidateJsonPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SendAPIService) SendValidateJsonPostExecute(r ApiSendValidateJsonPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendAPIService.SendValidateJsonPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/send/validate/json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fatturaOrdinaria == nil {
		return nil, reportError("fatturaOrdinaria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fatturaOrdinaria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendValidatePostRequest struct {
	ctx context.Context
	ApiService *SendAPIService
	send *Send
}

func (r ApiSendValidatePostRequest) Send(send Send) ApiSendValidatePostRequest {
	r.send = &send
	return r
}

func (r ApiSendValidatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendValidatePostExecute(r)
}

/*
SendValidatePost Validate an invoice

Send invoices are the invoices that are sent to the SDI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendValidatePostRequest
*/
func (a *SendAPIService) SendValidatePost(ctx context.Context) ApiSendValidatePostRequest {
	return ApiSendValidatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SendAPIService) SendValidatePostExecute(r ApiSendValidatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendAPIService.SendValidatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/send/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.send == nil {
		return nil, reportError("send is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.send
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendValidateXmlPostRequest struct {
	ctx context.Context
	ApiService *SendAPIService
	fatturaOrdinaria *FatturaOrdinaria
}

func (r ApiSendValidateXmlPostRequest) FatturaOrdinaria(fatturaOrdinaria FatturaOrdinaria) ApiSendValidateXmlPostRequest {
	r.fatturaOrdinaria = &fatturaOrdinaria
	return r
}

func (r ApiSendValidateXmlPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendValidateXmlPostExecute(r)
}

/*
SendValidateXmlPost Validate an invoice by xml

Send invoices are the invoices that are sent to the SDI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendValidateXmlPostRequest
*/
func (a *SendAPIService) SendValidateXmlPost(ctx context.Context) ApiSendValidateXmlPostRequest {
	return ApiSendValidateXmlPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SendAPIService) SendValidateXmlPostExecute(r ApiSendValidateXmlPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendAPIService.SendValidateXmlPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/send/validate/xml"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fatturaOrdinaria == nil {
		return nil, reportError("fatturaOrdinaria is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fatturaOrdinaria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendXmlPostRequest struct {
	ctx context.Context
	ApiService *SendAPIService
	fatturaOrdinaria *FatturaOrdinaria
	validate *bool
	signature *string
}

func (r ApiSendXmlPostRequest) FatturaOrdinaria(fatturaOrdinaria FatturaOrdinaria) ApiSendXmlPostRequest {
	r.fatturaOrdinaria = &fatturaOrdinaria
	return r
}

// Validate the document first, and reject it on failure.
func (r ApiSendXmlPostRequest) Validate(validate bool) ApiSendXmlPostRequest {
	r.validate = &validate
	return r
}

// Whether to digitally sign the document.
func (r ApiSendXmlPostRequest) Signature(signature string) ApiSendXmlPostRequest {
	r.signature = &signature
	return r
}

func (r ApiSendXmlPostRequest) Execute() (*Send, *http.Response, error) {
	return r.ApiService.SendXmlPostExecute(r)
}

/*
SendXmlPost Add an invoice by xml

Send invoices are the invoices that are sent to the SDI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendXmlPostRequest
*/
func (a *SendAPIService) SendXmlPost(ctx context.Context) ApiSendXmlPostRequest {
	return ApiSendXmlPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Send
func (a *SendAPIService) SendXmlPostExecute(r ApiSendXmlPostRequest) (*Send, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Send
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendAPIService.SendXmlPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/send/xml"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fatturaOrdinaria == nil {
		return localVarReturnValue, nil, reportError("fatturaOrdinaria is required and must be specified")
	}

	if r.validate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validate", r.validate, "form", "")
	} else {
		var defaultValue bool = false
		r.validate = &defaultValue
	}
	if r.signature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signature", r.signature, "form", "")
	} else {
		var defaultValue string = "Auto"
		r.signature = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fatturaOrdinaria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ProblemHttpResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
